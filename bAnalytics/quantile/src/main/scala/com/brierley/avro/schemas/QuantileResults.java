/**
 * Autogenerated by Avro
 *
 * DO NOT EDIT DIRECTLY
 */
package com.brierley.avro.schemas;

import org.apache.avro.specific.SpecificData;

@SuppressWarnings("all")
@org.apache.avro.specific.AvroGenerated
public class QuantileResults extends org.apache.avro.specific.SpecificRecordBase implements org.apache.avro.specific.SpecificRecord {
  private static final long serialVersionUID = 979557648816511799L;
  public static final org.apache.avro.Schema SCHEMA$ = new org.apache.avro.Schema.Parser().parse("{\"type\":\"record\",\"name\":\"QuantileResults\",\"namespace\":\"com.brierley.avro.schemas\",\"fields\":[{\"name\":\"jobKey\",\"type\":\"string\",\"doc\":\"unique job identifier\"},{\"name\":\"numRecords\",\"type\":\"long\",\"doc\":\"total number of records in the given dataset\"},{\"name\":\"completionTime\",\"type\":\"string\",\"doc\":\"The time the spark job finished and posted the results to kafka\"},{\"name\":\"minDate\",\"type\":\"string\",\"doc\":\"Beginning date after any required trimming based on given length of time\"},{\"name\":\"maxDate\",\"type\":\"string\",\"doc\":\"End date of the dataset after trimming to whole month/week\"},{\"name\":\"dimension\",\"type\":\"string\",\"doc\":\"dimensions: STORE or CUSTOMER, what are you quantiling by\"},{\"name\":\"quantileResults\",\"type\":{\"type\":\"array\",\"items\":{\"type\":\"record\",\"name\":\"quantilePeriodResults\",\"doc\":\"each record represents the results of single period of time\",\"fields\":[{\"name\":\"timePeriod\",\"type\":\"int\",\"doc\":\"Quantile Period, calculated ascending\"},{\"name\":\"quantile\",\"type\":\"int\",\"doc\":\"Quantile bucket\"},{\"name\":\"totalCount\",\"type\":\"long\",\"doc\":\"Total distinct count of customers/stores in the group determined by the segment above\"},{\"name\":\"totalVisits\",\"type\":\"long\",\"doc\":\"Total number of visits per customer/store determined by the segment\"},{\"name\":\"totalSpend\",\"type\":\"double\",\"doc\":\"Total spend per customer/store determined by the segment\"},{\"name\":\"totalUnits\",\"type\":\"long\",\"doc\":\"Total number of items per customer/store determined by the segment\"},{\"name\":\"totalDisc\",\"type\":\"double\",\"doc\":\"Total discount per customer/store determined by the segment, if discount is not given this will return 0\"},{\"name\":\"avgVisits\",\"type\":\"double\",\"doc\":\"totalVisits/totalCount\"},{\"name\":\"avgSpend\",\"type\":\"double\",\"doc\":\"totalSpend/totalCount\"},{\"name\":\"avgUnits\",\"type\":\"double\",\"doc\":\"totalUnits/totalCount\"},{\"name\":\"avgDisc\",\"type\":\"double\",\"doc\":\"totalDisc/totalCount, if discount was not given this will return 0\"},{\"name\":\"avgVisitSpend\",\"type\":\"double\",\"doc\":\"totalSpend/totalVisits\"},{\"name\":\"avgVisitUnits\",\"type\":\"double\",\"doc\":\"totalUnits/totalVisits\"},{\"name\":\"avgVisitDisc\",\"type\":\"double\",\"doc\":\"totalDisc/totalVisits\"},{\"name\":\"avgRecency\",\"type\":[\"null\",\"double\"],\"doc\":\"average days of last visit from max date in dataset, CUSTOMER dimension only\"},{\"name\":\"avgItemSales\",\"type\":[\"null\",\"double\"],\"doc\":\"totalSpend/totalUnits, CUSTOMER dimension only\"},{\"name\":\"avgItemDisc\",\"type\":[\"null\",\"double\"],\"doc\":\"totalDisc/totalUnits, CUSTOMER dimension only\"},{\"name\":\"totalCust\",\"type\":[\"null\",\"long\"],\"doc\":\"Total number of customers for STORE dimension only\"},{\"name\":\"avgStoreCust\",\"type\":[\"null\",\"double\"],\"doc\":\"totalCust/totalCount, STORE dimension only\"},{\"name\":\"avgCustSales\",\"type\":[\"null\",\"double\"],\"doc\":\"totalSpend/totalCust, STORE dimension only\"},{\"name\":\"avgCustVisits\",\"type\":[\"null\",\"double\"],\"doc\":\"totalVisits/totalCust, STORE dimension only\"},{\"name\":\"avgCustUnits\",\"type\":[\"null\",\"double\"],\"doc\":\"totalUnits/totalCust, STORE dimension only\"}]}}},{\"name\":\"productResults\",\"type\":{\"type\":\"array\",\"items\":{\"type\":\"record\",\"name\":\"quantileProductResults\",\"doc\":\"each record represents the results of single period of time\",\"fields\":[{\"name\":\"timePeriod\",\"type\":\"int\",\"doc\":\"Quantile Period, calculated ascending\"},{\"name\":\"quantile\",\"type\":\"int\",\"doc\":\"Quantile bucket\"},{\"name\":\"columnName\",\"type\":\"string\",\"doc\":\"Which input product column are these rankings for, user defines columns\"},{\"name\":\"ProductSpend\",\"type\":{\"type\":\"array\",\"items\":{\"type\":\"record\",\"name\":\"productSpend\",\"fields\":[{\"name\":\"product\",\"type\":\"string\"},{\"name\":\"rank\",\"type\":\"int\"},{\"name\":\"spend\",\"type\":\"double\"},{\"name\":\"position\",\"type\":\"string\"}]}},\"doc\":\"Top products by spend, per quantile group, defaults to 10 products\"},{\"name\":\"ProductCount\",\"type\":{\"type\":\"array\",\"items\":{\"type\":\"record\",\"name\":\"productCount\",\"fields\":[{\"name\":\"product\",\"type\":\"string\"},{\"name\":\"rank\",\"type\":\"int\"},{\"name\":\"count\",\"type\":\"long\"},{\"name\":\"position\",\"type\":\"string\"}]}},\"doc\":\"Top products by total units purchased per quantile group, defaults to 10 products\"}]}}},{\"name\":\"migrationResults\",\"type\":{\"type\":\"array\",\"items\":{\"type\":\"record\",\"name\":\"quantileMigrationResults\",\"doc\":\"Each record gives data for a single time period, and contains arrays to hold all quantile data\",\"fields\":[{\"name\":\"timePeriod\",\"type\":\"int\",\"doc\":\"Current Time period\"},{\"name\":\"migrationData\",\"type\":{\"type\":\"array\",\"items\":{\"type\":\"record\",\"name\":\"migrationArray\",\"fields\":[{\"name\":\"fromQuantile\",\"type\":\"int\",\"doc\":\"Quantile that they were in for PREVIOUS time period\"},{\"name\":\"currentQuantile\",\"type\":\"int\",\"doc\":\"Quantile that they belong to for CURRENT time period\"},{\"name\":\"migrationCount\",\"type\":\"long\",\"doc\":\"Total number that moved fromQuantile -> currentQuantile\"}]}}},{\"name\":\"quantileTotals\",\"type\":{\"type\":\"array\",\"items\":{\"type\":\"record\",\"name\":\"newTotal\",\"fields\":[{\"name\":\"quantile\",\"type\":\"int\",\"doc\":\"quantile for which totals apply to in the current time period\"},{\"name\":\"newCount\",\"type\":\"long\",\"doc\":\"Count of those not seen in PREVIOUS period, those not represented in migrationArray\"}]}}}]}}}]}");
  public static org.apache.avro.Schema getClassSchema() { return SCHEMA$; }
  /** unique job identifier */
  @Deprecated public java.lang.CharSequence jobKey;
  /** total number of records in the given dataset */
  @Deprecated public long numRecords;
  /** The time the spark job finished and posted the results to kafka */
  @Deprecated public java.lang.CharSequence completionTime;
  /** Beginning date after any required trimming based on given length of time */
  @Deprecated public java.lang.CharSequence minDate;
  /** End date of the dataset after trimming to whole month/week */
  @Deprecated public java.lang.CharSequence maxDate;
  /** dimensions: STORE or CUSTOMER, what are you quantiling by */
  @Deprecated public java.lang.CharSequence dimension;
  @Deprecated public java.util.List<com.brierley.avro.schemas.quantilePeriodResults> quantileResults;
  @Deprecated public java.util.List<com.brierley.avro.schemas.quantileProductResults> productResults;
  @Deprecated public java.util.List<com.brierley.avro.schemas.quantileMigrationResults> migrationResults;

  /**
   * Default constructor.  Note that this does not initialize fields
   * to their default values from the schema.  If that is desired then
   * one should use <code>newBuilder()</code>.
   */
  public QuantileResults() {}

  /**
   * All-args constructor.
   * @param jobKey unique job identifier
   * @param numRecords total number of records in the given dataset
   * @param completionTime The time the spark job finished and posted the results to kafka
   * @param minDate Beginning date after any required trimming based on given length of time
   * @param maxDate End date of the dataset after trimming to whole month/week
   * @param dimension dimensions: STORE or CUSTOMER, what are you quantiling by
   * @param quantileResults The new value for quantileResults
   * @param productResults The new value for productResults
   * @param migrationResults The new value for migrationResults
   */
  public QuantileResults(java.lang.CharSequence jobKey, java.lang.Long numRecords, java.lang.CharSequence completionTime, java.lang.CharSequence minDate, java.lang.CharSequence maxDate, java.lang.CharSequence dimension, java.util.List<com.brierley.avro.schemas.quantilePeriodResults> quantileResults, java.util.List<com.brierley.avro.schemas.quantileProductResults> productResults, java.util.List<com.brierley.avro.schemas.quantileMigrationResults> migrationResults) {
    this.jobKey = jobKey;
    this.numRecords = numRecords;
    this.completionTime = completionTime;
    this.minDate = minDate;
    this.maxDate = maxDate;
    this.dimension = dimension;
    this.quantileResults = quantileResults;
    this.productResults = productResults;
    this.migrationResults = migrationResults;
  }

  public org.apache.avro.Schema getSchema() { return SCHEMA$; }
  // Used by DatumWriter.  Applications should not call.
  public java.lang.Object get(int field$) {
    switch (field$) {
    case 0: return jobKey;
    case 1: return numRecords;
    case 2: return completionTime;
    case 3: return minDate;
    case 4: return maxDate;
    case 5: return dimension;
    case 6: return quantileResults;
    case 7: return productResults;
    case 8: return migrationResults;
    default: throw new org.apache.avro.AvroRuntimeException("Bad index");
    }
  }

  // Used by DatumReader.  Applications should not call.
  @SuppressWarnings(value="unchecked")
  public void put(int field$, java.lang.Object value$) {
    switch (field$) {
    case 0: jobKey = (java.lang.CharSequence)value$; break;
    case 1: numRecords = (java.lang.Long)value$; break;
    case 2: completionTime = (java.lang.CharSequence)value$; break;
    case 3: minDate = (java.lang.CharSequence)value$; break;
    case 4: maxDate = (java.lang.CharSequence)value$; break;
    case 5: dimension = (java.lang.CharSequence)value$; break;
    case 6: quantileResults = (java.util.List<com.brierley.avro.schemas.quantilePeriodResults>)value$; break;
    case 7: productResults = (java.util.List<com.brierley.avro.schemas.quantileProductResults>)value$; break;
    case 8: migrationResults = (java.util.List<com.brierley.avro.schemas.quantileMigrationResults>)value$; break;
    default: throw new org.apache.avro.AvroRuntimeException("Bad index");
    }
  }

  /**
   * Gets the value of the 'jobKey' field.
   * @return unique job identifier
   */
  public java.lang.CharSequence getJobKey() {
    return jobKey;
  }

  /**
   * Sets the value of the 'jobKey' field.
   * unique job identifier
   * @param value the value to set.
   */
  public void setJobKey(java.lang.CharSequence value) {
    this.jobKey = value;
  }

  /**
   * Gets the value of the 'numRecords' field.
   * @return total number of records in the given dataset
   */
  public java.lang.Long getNumRecords() {
    return numRecords;
  }

  /**
   * Sets the value of the 'numRecords' field.
   * total number of records in the given dataset
   * @param value the value to set.
   */
  public void setNumRecords(java.lang.Long value) {
    this.numRecords = value;
  }

  /**
   * Gets the value of the 'completionTime' field.
   * @return The time the spark job finished and posted the results to kafka
   */
  public java.lang.CharSequence getCompletionTime() {
    return completionTime;
  }

  /**
   * Sets the value of the 'completionTime' field.
   * The time the spark job finished and posted the results to kafka
   * @param value the value to set.
   */
  public void setCompletionTime(java.lang.CharSequence value) {
    this.completionTime = value;
  }

  /**
   * Gets the value of the 'minDate' field.
   * @return Beginning date after any required trimming based on given length of time
   */
  public java.lang.CharSequence getMinDate() {
    return minDate;
  }

  /**
   * Sets the value of the 'minDate' field.
   * Beginning date after any required trimming based on given length of time
   * @param value the value to set.
   */
  public void setMinDate(java.lang.CharSequence value) {
    this.minDate = value;
  }

  /**
   * Gets the value of the 'maxDate' field.
   * @return End date of the dataset after trimming to whole month/week
   */
  public java.lang.CharSequence getMaxDate() {
    return maxDate;
  }

  /**
   * Sets the value of the 'maxDate' field.
   * End date of the dataset after trimming to whole month/week
   * @param value the value to set.
   */
  public void setMaxDate(java.lang.CharSequence value) {
    this.maxDate = value;
  }

  /**
   * Gets the value of the 'dimension' field.
   * @return dimensions: STORE or CUSTOMER, what are you quantiling by
   */
  public java.lang.CharSequence getDimension() {
    return dimension;
  }

  /**
   * Sets the value of the 'dimension' field.
   * dimensions: STORE or CUSTOMER, what are you quantiling by
   * @param value the value to set.
   */
  public void setDimension(java.lang.CharSequence value) {
    this.dimension = value;
  }

  /**
   * Gets the value of the 'quantileResults' field.
   * @return The value of the 'quantileResults' field.
   */
  public java.util.List<com.brierley.avro.schemas.quantilePeriodResults> getQuantileResults() {
    return quantileResults;
  }

  /**
   * Sets the value of the 'quantileResults' field.
   * @param value the value to set.
   */
  public void setQuantileResults(java.util.List<com.brierley.avro.schemas.quantilePeriodResults> value) {
    this.quantileResults = value;
  }

  /**
   * Gets the value of the 'productResults' field.
   * @return The value of the 'productResults' field.
   */
  public java.util.List<com.brierley.avro.schemas.quantileProductResults> getProductResults() {
    return productResults;
  }

  /**
   * Sets the value of the 'productResults' field.
   * @param value the value to set.
   */
  public void setProductResults(java.util.List<com.brierley.avro.schemas.quantileProductResults> value) {
    this.productResults = value;
  }

  /**
   * Gets the value of the 'migrationResults' field.
   * @return The value of the 'migrationResults' field.
   */
  public java.util.List<com.brierley.avro.schemas.quantileMigrationResults> getMigrationResults() {
    return migrationResults;
  }

  /**
   * Sets the value of the 'migrationResults' field.
   * @param value the value to set.
   */
  public void setMigrationResults(java.util.List<com.brierley.avro.schemas.quantileMigrationResults> value) {
    this.migrationResults = value;
  }

  /**
   * Creates a new QuantileResults RecordBuilder.
   * @return A new QuantileResults RecordBuilder
   */
  public static com.brierley.avro.schemas.QuantileResults.Builder newBuilder() {
    return new com.brierley.avro.schemas.QuantileResults.Builder();
  }

  /**
   * Creates a new QuantileResults RecordBuilder by copying an existing Builder.
   * @param other The existing builder to copy.
   * @return A new QuantileResults RecordBuilder
   */
  public static com.brierley.avro.schemas.QuantileResults.Builder newBuilder(com.brierley.avro.schemas.QuantileResults.Builder other) {
    return new com.brierley.avro.schemas.QuantileResults.Builder(other);
  }

  /**
   * Creates a new QuantileResults RecordBuilder by copying an existing QuantileResults instance.
   * @param other The existing instance to copy.
   * @return A new QuantileResults RecordBuilder
   */
  public static com.brierley.avro.schemas.QuantileResults.Builder newBuilder(com.brierley.avro.schemas.QuantileResults other) {
    return new com.brierley.avro.schemas.QuantileResults.Builder(other);
  }

  /**
   * RecordBuilder for QuantileResults instances.
   */
  public static class Builder extends org.apache.avro.specific.SpecificRecordBuilderBase<QuantileResults>
    implements org.apache.avro.data.RecordBuilder<QuantileResults> {

    /** unique job identifier */
    private java.lang.CharSequence jobKey;
    /** total number of records in the given dataset */
    private long numRecords;
    /** The time the spark job finished and posted the results to kafka */
    private java.lang.CharSequence completionTime;
    /** Beginning date after any required trimming based on given length of time */
    private java.lang.CharSequence minDate;
    /** End date of the dataset after trimming to whole month/week */
    private java.lang.CharSequence maxDate;
    /** dimensions: STORE or CUSTOMER, what are you quantiling by */
    private java.lang.CharSequence dimension;
    private java.util.List<com.brierley.avro.schemas.quantilePeriodResults> quantileResults;
    private java.util.List<com.brierley.avro.schemas.quantileProductResults> productResults;
    private java.util.List<com.brierley.avro.schemas.quantileMigrationResults> migrationResults;

    /** Creates a new Builder */
    private Builder() {
      super(SCHEMA$);
    }

    /**
     * Creates a Builder by copying an existing Builder.
     * @param other The existing Builder to copy.
     */
    private Builder(com.brierley.avro.schemas.QuantileResults.Builder other) {
      super(other);
      if (isValidValue(fields()[0], other.jobKey)) {
        this.jobKey = data().deepCopy(fields()[0].schema(), other.jobKey);
        fieldSetFlags()[0] = true;
      }
      if (isValidValue(fields()[1], other.numRecords)) {
        this.numRecords = data().deepCopy(fields()[1].schema(), other.numRecords);
        fieldSetFlags()[1] = true;
      }
      if (isValidValue(fields()[2], other.completionTime)) {
        this.completionTime = data().deepCopy(fields()[2].schema(), other.completionTime);
        fieldSetFlags()[2] = true;
      }
      if (isValidValue(fields()[3], other.minDate)) {
        this.minDate = data().deepCopy(fields()[3].schema(), other.minDate);
        fieldSetFlags()[3] = true;
      }
      if (isValidValue(fields()[4], other.maxDate)) {
        this.maxDate = data().deepCopy(fields()[4].schema(), other.maxDate);
        fieldSetFlags()[4] = true;
      }
      if (isValidValue(fields()[5], other.dimension)) {
        this.dimension = data().deepCopy(fields()[5].schema(), other.dimension);
        fieldSetFlags()[5] = true;
      }
      if (isValidValue(fields()[6], other.quantileResults)) {
        this.quantileResults = data().deepCopy(fields()[6].schema(), other.quantileResults);
        fieldSetFlags()[6] = true;
      }
      if (isValidValue(fields()[7], other.productResults)) {
        this.productResults = data().deepCopy(fields()[7].schema(), other.productResults);
        fieldSetFlags()[7] = true;
      }
      if (isValidValue(fields()[8], other.migrationResults)) {
        this.migrationResults = data().deepCopy(fields()[8].schema(), other.migrationResults);
        fieldSetFlags()[8] = true;
      }
    }

    /**
     * Creates a Builder by copying an existing QuantileResults instance
     * @param other The existing instance to copy.
     */
    private Builder(com.brierley.avro.schemas.QuantileResults other) {
            super(SCHEMA$);
      if (isValidValue(fields()[0], other.jobKey)) {
        this.jobKey = data().deepCopy(fields()[0].schema(), other.jobKey);
        fieldSetFlags()[0] = true;
      }
      if (isValidValue(fields()[1], other.numRecords)) {
        this.numRecords = data().deepCopy(fields()[1].schema(), other.numRecords);
        fieldSetFlags()[1] = true;
      }
      if (isValidValue(fields()[2], other.completionTime)) {
        this.completionTime = data().deepCopy(fields()[2].schema(), other.completionTime);
        fieldSetFlags()[2] = true;
      }
      if (isValidValue(fields()[3], other.minDate)) {
        this.minDate = data().deepCopy(fields()[3].schema(), other.minDate);
        fieldSetFlags()[3] = true;
      }
      if (isValidValue(fields()[4], other.maxDate)) {
        this.maxDate = data().deepCopy(fields()[4].schema(), other.maxDate);
        fieldSetFlags()[4] = true;
      }
      if (isValidValue(fields()[5], other.dimension)) {
        this.dimension = data().deepCopy(fields()[5].schema(), other.dimension);
        fieldSetFlags()[5] = true;
      }
      if (isValidValue(fields()[6], other.quantileResults)) {
        this.quantileResults = data().deepCopy(fields()[6].schema(), other.quantileResults);
        fieldSetFlags()[6] = true;
      }
      if (isValidValue(fields()[7], other.productResults)) {
        this.productResults = data().deepCopy(fields()[7].schema(), other.productResults);
        fieldSetFlags()[7] = true;
      }
      if (isValidValue(fields()[8], other.migrationResults)) {
        this.migrationResults = data().deepCopy(fields()[8].schema(), other.migrationResults);
        fieldSetFlags()[8] = true;
      }
    }

    /**
      * Gets the value of the 'jobKey' field.
      * unique job identifier
      * @return The value.
      */
    public java.lang.CharSequence getJobKey() {
      return jobKey;
    }

    /**
      * Sets the value of the 'jobKey' field.
      * unique job identifier
      * @param value The value of 'jobKey'.
      * @return This builder.
      */
    public com.brierley.avro.schemas.QuantileResults.Builder setJobKey(java.lang.CharSequence value) {
      validate(fields()[0], value);
      this.jobKey = value;
      fieldSetFlags()[0] = true;
      return this;
    }

    /**
      * Checks whether the 'jobKey' field has been set.
      * unique job identifier
      * @return True if the 'jobKey' field has been set, false otherwise.
      */
    public boolean hasJobKey() {
      return fieldSetFlags()[0];
    }


    /**
      * Clears the value of the 'jobKey' field.
      * unique job identifier
      * @return This builder.
      */
    public com.brierley.avro.schemas.QuantileResults.Builder clearJobKey() {
      jobKey = null;
      fieldSetFlags()[0] = false;
      return this;
    }

    /**
      * Gets the value of the 'numRecords' field.
      * total number of records in the given dataset
      * @return The value.
      */
    public java.lang.Long getNumRecords() {
      return numRecords;
    }

    /**
      * Sets the value of the 'numRecords' field.
      * total number of records in the given dataset
      * @param value The value of 'numRecords'.
      * @return This builder.
      */
    public com.brierley.avro.schemas.QuantileResults.Builder setNumRecords(long value) {
      validate(fields()[1], value);
      this.numRecords = value;
      fieldSetFlags()[1] = true;
      return this;
    }

    /**
      * Checks whether the 'numRecords' field has been set.
      * total number of records in the given dataset
      * @return True if the 'numRecords' field has been set, false otherwise.
      */
    public boolean hasNumRecords() {
      return fieldSetFlags()[1];
    }


    /**
      * Clears the value of the 'numRecords' field.
      * total number of records in the given dataset
      * @return This builder.
      */
    public com.brierley.avro.schemas.QuantileResults.Builder clearNumRecords() {
      fieldSetFlags()[1] = false;
      return this;
    }

    /**
      * Gets the value of the 'completionTime' field.
      * The time the spark job finished and posted the results to kafka
      * @return The value.
      */
    public java.lang.CharSequence getCompletionTime() {
      return completionTime;
    }

    /**
      * Sets the value of the 'completionTime' field.
      * The time the spark job finished and posted the results to kafka
      * @param value The value of 'completionTime'.
      * @return This builder.
      */
    public com.brierley.avro.schemas.QuantileResults.Builder setCompletionTime(java.lang.CharSequence value) {
      validate(fields()[2], value);
      this.completionTime = value;
      fieldSetFlags()[2] = true;
      return this;
    }

    /**
      * Checks whether the 'completionTime' field has been set.
      * The time the spark job finished and posted the results to kafka
      * @return True if the 'completionTime' field has been set, false otherwise.
      */
    public boolean hasCompletionTime() {
      return fieldSetFlags()[2];
    }


    /**
      * Clears the value of the 'completionTime' field.
      * The time the spark job finished and posted the results to kafka
      * @return This builder.
      */
    public com.brierley.avro.schemas.QuantileResults.Builder clearCompletionTime() {
      completionTime = null;
      fieldSetFlags()[2] = false;
      return this;
    }

    /**
      * Gets the value of the 'minDate' field.
      * Beginning date after any required trimming based on given length of time
      * @return The value.
      */
    public java.lang.CharSequence getMinDate() {
      return minDate;
    }

    /**
      * Sets the value of the 'minDate' field.
      * Beginning date after any required trimming based on given length of time
      * @param value The value of 'minDate'.
      * @return This builder.
      */
    public com.brierley.avro.schemas.QuantileResults.Builder setMinDate(java.lang.CharSequence value) {
      validate(fields()[3], value);
      this.minDate = value;
      fieldSetFlags()[3] = true;
      return this;
    }

    /**
      * Checks whether the 'minDate' field has been set.
      * Beginning date after any required trimming based on given length of time
      * @return True if the 'minDate' field has been set, false otherwise.
      */
    public boolean hasMinDate() {
      return fieldSetFlags()[3];
    }


    /**
      * Clears the value of the 'minDate' field.
      * Beginning date after any required trimming based on given length of time
      * @return This builder.
      */
    public com.brierley.avro.schemas.QuantileResults.Builder clearMinDate() {
      minDate = null;
      fieldSetFlags()[3] = false;
      return this;
    }

    /**
      * Gets the value of the 'maxDate' field.
      * End date of the dataset after trimming to whole month/week
      * @return The value.
      */
    public java.lang.CharSequence getMaxDate() {
      return maxDate;
    }

    /**
      * Sets the value of the 'maxDate' field.
      * End date of the dataset after trimming to whole month/week
      * @param value The value of 'maxDate'.
      * @return This builder.
      */
    public com.brierley.avro.schemas.QuantileResults.Builder setMaxDate(java.lang.CharSequence value) {
      validate(fields()[4], value);
      this.maxDate = value;
      fieldSetFlags()[4] = true;
      return this;
    }

    /**
      * Checks whether the 'maxDate' field has been set.
      * End date of the dataset after trimming to whole month/week
      * @return True if the 'maxDate' field has been set, false otherwise.
      */
    public boolean hasMaxDate() {
      return fieldSetFlags()[4];
    }


    /**
      * Clears the value of the 'maxDate' field.
      * End date of the dataset after trimming to whole month/week
      * @return This builder.
      */
    public com.brierley.avro.schemas.QuantileResults.Builder clearMaxDate() {
      maxDate = null;
      fieldSetFlags()[4] = false;
      return this;
    }

    /**
      * Gets the value of the 'dimension' field.
      * dimensions: STORE or CUSTOMER, what are you quantiling by
      * @return The value.
      */
    public java.lang.CharSequence getDimension() {
      return dimension;
    }

    /**
      * Sets the value of the 'dimension' field.
      * dimensions: STORE or CUSTOMER, what are you quantiling by
      * @param value The value of 'dimension'.
      * @return This builder.
      */
    public com.brierley.avro.schemas.QuantileResults.Builder setDimension(java.lang.CharSequence value) {
      validate(fields()[5], value);
      this.dimension = value;
      fieldSetFlags()[5] = true;
      return this;
    }

    /**
      * Checks whether the 'dimension' field has been set.
      * dimensions: STORE or CUSTOMER, what are you quantiling by
      * @return True if the 'dimension' field has been set, false otherwise.
      */
    public boolean hasDimension() {
      return fieldSetFlags()[5];
    }


    /**
      * Clears the value of the 'dimension' field.
      * dimensions: STORE or CUSTOMER, what are you quantiling by
      * @return This builder.
      */
    public com.brierley.avro.schemas.QuantileResults.Builder clearDimension() {
      dimension = null;
      fieldSetFlags()[5] = false;
      return this;
    }

    /**
      * Gets the value of the 'quantileResults' field.
      * @return The value.
      */
    public java.util.List<com.brierley.avro.schemas.quantilePeriodResults> getQuantileResults() {
      return quantileResults;
    }

    /**
      * Sets the value of the 'quantileResults' field.
      * @param value The value of 'quantileResults'.
      * @return This builder.
      */
    public com.brierley.avro.schemas.QuantileResults.Builder setQuantileResults(java.util.List<com.brierley.avro.schemas.quantilePeriodResults> value) {
      validate(fields()[6], value);
      this.quantileResults = value;
      fieldSetFlags()[6] = true;
      return this;
    }

    /**
      * Checks whether the 'quantileResults' field has been set.
      * @return True if the 'quantileResults' field has been set, false otherwise.
      */
    public boolean hasQuantileResults() {
      return fieldSetFlags()[6];
    }


    /**
      * Clears the value of the 'quantileResults' field.
      * @return This builder.
      */
    public com.brierley.avro.schemas.QuantileResults.Builder clearQuantileResults() {
      quantileResults = null;
      fieldSetFlags()[6] = false;
      return this;
    }

    /**
      * Gets the value of the 'productResults' field.
      * @return The value.
      */
    public java.util.List<com.brierley.avro.schemas.quantileProductResults> getProductResults() {
      return productResults;
    }

    /**
      * Sets the value of the 'productResults' field.
      * @param value The value of 'productResults'.
      * @return This builder.
      */
    public com.brierley.avro.schemas.QuantileResults.Builder setProductResults(java.util.List<com.brierley.avro.schemas.quantileProductResults> value) {
      validate(fields()[7], value);
      this.productResults = value;
      fieldSetFlags()[7] = true;
      return this;
    }

    /**
      * Checks whether the 'productResults' field has been set.
      * @return True if the 'productResults' field has been set, false otherwise.
      */
    public boolean hasProductResults() {
      return fieldSetFlags()[7];
    }


    /**
      * Clears the value of the 'productResults' field.
      * @return This builder.
      */
    public com.brierley.avro.schemas.QuantileResults.Builder clearProductResults() {
      productResults = null;
      fieldSetFlags()[7] = false;
      return this;
    }

    /**
      * Gets the value of the 'migrationResults' field.
      * @return The value.
      */
    public java.util.List<com.brierley.avro.schemas.quantileMigrationResults> getMigrationResults() {
      return migrationResults;
    }

    /**
      * Sets the value of the 'migrationResults' field.
      * @param value The value of 'migrationResults'.
      * @return This builder.
      */
    public com.brierley.avro.schemas.QuantileResults.Builder setMigrationResults(java.util.List<com.brierley.avro.schemas.quantileMigrationResults> value) {
      validate(fields()[8], value);
      this.migrationResults = value;
      fieldSetFlags()[8] = true;
      return this;
    }

    /**
      * Checks whether the 'migrationResults' field has been set.
      * @return True if the 'migrationResults' field has been set, false otherwise.
      */
    public boolean hasMigrationResults() {
      return fieldSetFlags()[8];
    }


    /**
      * Clears the value of the 'migrationResults' field.
      * @return This builder.
      */
    public com.brierley.avro.schemas.QuantileResults.Builder clearMigrationResults() {
      migrationResults = null;
      fieldSetFlags()[8] = false;
      return this;
    }

    @Override
    public QuantileResults build() {
      try {
        QuantileResults record = new QuantileResults();
        record.jobKey = fieldSetFlags()[0] ? this.jobKey : (java.lang.CharSequence) defaultValue(fields()[0]);
        record.numRecords = fieldSetFlags()[1] ? this.numRecords : (java.lang.Long) defaultValue(fields()[1]);
        record.completionTime = fieldSetFlags()[2] ? this.completionTime : (java.lang.CharSequence) defaultValue(fields()[2]);
        record.minDate = fieldSetFlags()[3] ? this.minDate : (java.lang.CharSequence) defaultValue(fields()[3]);
        record.maxDate = fieldSetFlags()[4] ? this.maxDate : (java.lang.CharSequence) defaultValue(fields()[4]);
        record.dimension = fieldSetFlags()[5] ? this.dimension : (java.lang.CharSequence) defaultValue(fields()[5]);
        record.quantileResults = fieldSetFlags()[6] ? this.quantileResults : (java.util.List<com.brierley.avro.schemas.quantilePeriodResults>) defaultValue(fields()[6]);
        record.productResults = fieldSetFlags()[7] ? this.productResults : (java.util.List<com.brierley.avro.schemas.quantileProductResults>) defaultValue(fields()[7]);
        record.migrationResults = fieldSetFlags()[8] ? this.migrationResults : (java.util.List<com.brierley.avro.schemas.quantileMigrationResults>) defaultValue(fields()[8]);
        return record;
      } catch (Exception e) {
        throw new org.apache.avro.AvroRuntimeException(e);
      }
    }
  }

  private static final org.apache.avro.io.DatumWriter
    WRITER$ = new org.apache.avro.specific.SpecificDatumWriter(SCHEMA$);

  @Override public void writeExternal(java.io.ObjectOutput out)
    throws java.io.IOException {
    WRITER$.write(this, SpecificData.getEncoder(out));
  }

  private static final org.apache.avro.io.DatumReader
    READER$ = new org.apache.avro.specific.SpecificDatumReader(SCHEMA$);

  @Override public void readExternal(java.io.ObjectInput in)
    throws java.io.IOException {
    READER$.read(this, SpecificData.getDecoder(in));
  }

}
