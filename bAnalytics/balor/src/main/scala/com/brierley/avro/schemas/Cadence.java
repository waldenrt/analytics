/**
 * Autogenerated by Avro
 *
 * DO NOT EDIT DIRECTLY
 */
package com.brierley.avro.schemas;

import org.apache.avro.specific.SpecificData;

@SuppressWarnings("all")
@org.apache.avro.specific.AvroGenerated
public class Cadence extends org.apache.avro.specific.SpecificRecordBase implements org.apache.avro.specific.SpecificRecord {
  private static final long serialVersionUID = 8638389832659097298L;
  public static final org.apache.avro.Schema SCHEMA$ = new org.apache.avro.Schema.Parser().parse("{\"type\":\"record\",\"name\":\"Cadence\",\"namespace\":\"com.brierley.avro.schemas\",\"fields\":[{\"name\":\"jobKey\",\"type\":\"string\",\"doc\":\"unique job identifier to find results in hbase\"},{\"name\":\"numRecords\",\"type\":\"long\",\"doc\":\"Total number of records in the given dataset used to calculate the cadence\"},{\"name\":\"singleVisit\",\"type\":\"long\",\"doc\":\"Number of customers with exactly 1 transaction in the entire dataset.\"},{\"name\":\"totalCusts\",\"type\":\"long\",\"doc\":\"Total number of unique customers for entire dataset.\"},{\"name\":\"completionTime\",\"type\":\"string\",\"doc\":\"The time the spark job finished and sent the record.\"},{\"name\":\"minDateCadence\",\"type\":\"string\",\"doc\":\"Beginning date of entire date set used to calculate the cadence\"},{\"name\":\"maxDateCadence\",\"type\":\"string\",\"doc\":\"Last date of entire data set used to calculate the cadence\"},{\"name\":\"rawCadence\",\"type\":\"double\",\"doc\":\"The cadence calculated with the given percentage before rounding to an approved timeperiod.\"},{\"name\":\"normalizedCadence\",\"type\":\"string\",\"doc\":\"The cadence value that will be used when running the actual balor calculations, this always rounds up.\"},{\"name\":\"numTimePeriods\",\"type\":\"int\",\"doc\":\"The number of time periods that are present in the given data file using the normalized cadence value.\"},{\"name\":\"percentile\",\"type\":\"double\",\"doc\":\"The percentile that was used in calculating the cadence. Defaults to .80, but power users can change it.\"},{\"name\":\"FreqTable\",\"type\":{\"type\":\"array\",\"items\":{\"type\":\"record\",\"name\":\"FreqRow\",\"fields\":[{\"name\":\"cadence\",\"type\":\"int\",\"doc\":\"The cadence value for the following frequencies in days\"},{\"name\":\"frequency\",\"type\":\"long\",\"doc\":\"The number of times that the cadence appears in the dataset\"},{\"name\":\"cumFreq\",\"type\":\"long\",\"doc\":\"The cumulative frequency of the all previous cadence values.\"}]}}}]}");
  public static org.apache.avro.Schema getClassSchema() { return SCHEMA$; }
  /** unique job identifier to find results in hbase */
  @Deprecated public java.lang.CharSequence jobKey;
  /** Total number of records in the given dataset used to calculate the cadence */
  @Deprecated public long numRecords;
  /** Number of customers with exactly 1 transaction in the entire dataset. */
  @Deprecated public long singleVisit;
  /** Total number of unique customers for entire dataset. */
  @Deprecated public long totalCusts;
  /** The time the spark job finished and sent the record. */
  @Deprecated public java.lang.CharSequence completionTime;
  /** Beginning date of entire date set used to calculate the cadence */
  @Deprecated public java.lang.CharSequence minDateCadence;
  /** Last date of entire data set used to calculate the cadence */
  @Deprecated public java.lang.CharSequence maxDateCadence;
  /** The cadence calculated with the given percentage before rounding to an approved timeperiod. */
  @Deprecated public double rawCadence;
  /** The cadence value that will be used when running the actual balor calculations, this always rounds up. */
  @Deprecated public java.lang.CharSequence normalizedCadence;
  /** The number of time periods that are present in the given data file using the normalized cadence value. */
  @Deprecated public int numTimePeriods;
  /** The percentile that was used in calculating the cadence. Defaults to .80, but power users can change it. */
  @Deprecated public double percentile;
  @Deprecated public java.util.List<com.brierley.avro.schemas.FreqRow> FreqTable;

  /**
   * Default constructor.  Note that this does not initialize fields
   * to their default values from the schema.  If that is desired then
   * one should use <code>newBuilder()</code>.
   */
  public Cadence() {}

  /**
   * All-args constructor.
   * @param jobKey unique job identifier to find results in hbase
   * @param numRecords Total number of records in the given dataset used to calculate the cadence
   * @param singleVisit Number of customers with exactly 1 transaction in the entire dataset.
   * @param totalCusts Total number of unique customers for entire dataset.
   * @param completionTime The time the spark job finished and sent the record.
   * @param minDateCadence Beginning date of entire date set used to calculate the cadence
   * @param maxDateCadence Last date of entire data set used to calculate the cadence
   * @param rawCadence The cadence calculated with the given percentage before rounding to an approved timeperiod.
   * @param normalizedCadence The cadence value that will be used when running the actual balor calculations, this always rounds up.
   * @param numTimePeriods The number of time periods that are present in the given data file using the normalized cadence value.
   * @param percentile The percentile that was used in calculating the cadence. Defaults to .80, but power users can change it.
   * @param FreqTable The new value for FreqTable
   */
  public Cadence(java.lang.CharSequence jobKey, java.lang.Long numRecords, java.lang.Long singleVisit, java.lang.Long totalCusts, java.lang.CharSequence completionTime, java.lang.CharSequence minDateCadence, java.lang.CharSequence maxDateCadence, java.lang.Double rawCadence, java.lang.CharSequence normalizedCadence, java.lang.Integer numTimePeriods, java.lang.Double percentile, java.util.List<com.brierley.avro.schemas.FreqRow> FreqTable) {
    this.jobKey = jobKey;
    this.numRecords = numRecords;
    this.singleVisit = singleVisit;
    this.totalCusts = totalCusts;
    this.completionTime = completionTime;
    this.minDateCadence = minDateCadence;
    this.maxDateCadence = maxDateCadence;
    this.rawCadence = rawCadence;
    this.normalizedCadence = normalizedCadence;
    this.numTimePeriods = numTimePeriods;
    this.percentile = percentile;
    this.FreqTable = FreqTable;
  }

  public org.apache.avro.Schema getSchema() { return SCHEMA$; }
  // Used by DatumWriter.  Applications should not call.
  public java.lang.Object get(int field$) {
    switch (field$) {
    case 0: return jobKey;
    case 1: return numRecords;
    case 2: return singleVisit;
    case 3: return totalCusts;
    case 4: return completionTime;
    case 5: return minDateCadence;
    case 6: return maxDateCadence;
    case 7: return rawCadence;
    case 8: return normalizedCadence;
    case 9: return numTimePeriods;
    case 10: return percentile;
    case 11: return FreqTable;
    default: throw new org.apache.avro.AvroRuntimeException("Bad index");
    }
  }

  // Used by DatumReader.  Applications should not call.
  @SuppressWarnings(value="unchecked")
  public void put(int field$, java.lang.Object value$) {
    switch (field$) {
    case 0: jobKey = (java.lang.CharSequence)value$; break;
    case 1: numRecords = (java.lang.Long)value$; break;
    case 2: singleVisit = (java.lang.Long)value$; break;
    case 3: totalCusts = (java.lang.Long)value$; break;
    case 4: completionTime = (java.lang.CharSequence)value$; break;
    case 5: minDateCadence = (java.lang.CharSequence)value$; break;
    case 6: maxDateCadence = (java.lang.CharSequence)value$; break;
    case 7: rawCadence = (java.lang.Double)value$; break;
    case 8: normalizedCadence = (java.lang.CharSequence)value$; break;
    case 9: numTimePeriods = (java.lang.Integer)value$; break;
    case 10: percentile = (java.lang.Double)value$; break;
    case 11: FreqTable = (java.util.List<com.brierley.avro.schemas.FreqRow>)value$; break;
    default: throw new org.apache.avro.AvroRuntimeException("Bad index");
    }
  }

  /**
   * Gets the value of the 'jobKey' field.
   * @return unique job identifier to find results in hbase
   */
  public java.lang.CharSequence getJobKey() {
    return jobKey;
  }

  /**
   * Sets the value of the 'jobKey' field.
   * unique job identifier to find results in hbase
   * @param value the value to set.
   */
  public void setJobKey(java.lang.CharSequence value) {
    this.jobKey = value;
  }

  /**
   * Gets the value of the 'numRecords' field.
   * @return Total number of records in the given dataset used to calculate the cadence
   */
  public java.lang.Long getNumRecords() {
    return numRecords;
  }

  /**
   * Sets the value of the 'numRecords' field.
   * Total number of records in the given dataset used to calculate the cadence
   * @param value the value to set.
   */
  public void setNumRecords(java.lang.Long value) {
    this.numRecords = value;
  }

  /**
   * Gets the value of the 'singleVisit' field.
   * @return Number of customers with exactly 1 transaction in the entire dataset.
   */
  public java.lang.Long getSingleVisit() {
    return singleVisit;
  }

  /**
   * Sets the value of the 'singleVisit' field.
   * Number of customers with exactly 1 transaction in the entire dataset.
   * @param value the value to set.
   */
  public void setSingleVisit(java.lang.Long value) {
    this.singleVisit = value;
  }

  /**
   * Gets the value of the 'totalCusts' field.
   * @return Total number of unique customers for entire dataset.
   */
  public java.lang.Long getTotalCusts() {
    return totalCusts;
  }

  /**
   * Sets the value of the 'totalCusts' field.
   * Total number of unique customers for entire dataset.
   * @param value the value to set.
   */
  public void setTotalCusts(java.lang.Long value) {
    this.totalCusts = value;
  }

  /**
   * Gets the value of the 'completionTime' field.
   * @return The time the spark job finished and sent the record.
   */
  public java.lang.CharSequence getCompletionTime() {
    return completionTime;
  }

  /**
   * Sets the value of the 'completionTime' field.
   * The time the spark job finished and sent the record.
   * @param value the value to set.
   */
  public void setCompletionTime(java.lang.CharSequence value) {
    this.completionTime = value;
  }

  /**
   * Gets the value of the 'minDateCadence' field.
   * @return Beginning date of entire date set used to calculate the cadence
   */
  public java.lang.CharSequence getMinDateCadence() {
    return minDateCadence;
  }

  /**
   * Sets the value of the 'minDateCadence' field.
   * Beginning date of entire date set used to calculate the cadence
   * @param value the value to set.
   */
  public void setMinDateCadence(java.lang.CharSequence value) {
    this.minDateCadence = value;
  }

  /**
   * Gets the value of the 'maxDateCadence' field.
   * @return Last date of entire data set used to calculate the cadence
   */
  public java.lang.CharSequence getMaxDateCadence() {
    return maxDateCadence;
  }

  /**
   * Sets the value of the 'maxDateCadence' field.
   * Last date of entire data set used to calculate the cadence
   * @param value the value to set.
   */
  public void setMaxDateCadence(java.lang.CharSequence value) {
    this.maxDateCadence = value;
  }

  /**
   * Gets the value of the 'rawCadence' field.
   * @return The cadence calculated with the given percentage before rounding to an approved timeperiod.
   */
  public java.lang.Double getRawCadence() {
    return rawCadence;
  }

  /**
   * Sets the value of the 'rawCadence' field.
   * The cadence calculated with the given percentage before rounding to an approved timeperiod.
   * @param value the value to set.
   */
  public void setRawCadence(java.lang.Double value) {
    this.rawCadence = value;
  }

  /**
   * Gets the value of the 'normalizedCadence' field.
   * @return The cadence value that will be used when running the actual balor calculations, this always rounds up.
   */
  public java.lang.CharSequence getNormalizedCadence() {
    return normalizedCadence;
  }

  /**
   * Sets the value of the 'normalizedCadence' field.
   * The cadence value that will be used when running the actual balor calculations, this always rounds up.
   * @param value the value to set.
   */
  public void setNormalizedCadence(java.lang.CharSequence value) {
    this.normalizedCadence = value;
  }

  /**
   * Gets the value of the 'numTimePeriods' field.
   * @return The number of time periods that are present in the given data file using the normalized cadence value.
   */
  public java.lang.Integer getNumTimePeriods() {
    return numTimePeriods;
  }

  /**
   * Sets the value of the 'numTimePeriods' field.
   * The number of time periods that are present in the given data file using the normalized cadence value.
   * @param value the value to set.
   */
  public void setNumTimePeriods(java.lang.Integer value) {
    this.numTimePeriods = value;
  }

  /**
   * Gets the value of the 'percentile' field.
   * @return The percentile that was used in calculating the cadence. Defaults to .80, but power users can change it.
   */
  public java.lang.Double getPercentile() {
    return percentile;
  }

  /**
   * Sets the value of the 'percentile' field.
   * The percentile that was used in calculating the cadence. Defaults to .80, but power users can change it.
   * @param value the value to set.
   */
  public void setPercentile(java.lang.Double value) {
    this.percentile = value;
  }

  /**
   * Gets the value of the 'FreqTable' field.
   * @return The value of the 'FreqTable' field.
   */
  public java.util.List<com.brierley.avro.schemas.FreqRow> getFreqTable() {
    return FreqTable;
  }

  /**
   * Sets the value of the 'FreqTable' field.
   * @param value the value to set.
   */
  public void setFreqTable(java.util.List<com.brierley.avro.schemas.FreqRow> value) {
    this.FreqTable = value;
  }

  /**
   * Creates a new Cadence RecordBuilder.
   * @return A new Cadence RecordBuilder
   */
  public static com.brierley.avro.schemas.Cadence.Builder newBuilder() {
    return new com.brierley.avro.schemas.Cadence.Builder();
  }

  /**
   * Creates a new Cadence RecordBuilder by copying an existing Builder.
   * @param other The existing builder to copy.
   * @return A new Cadence RecordBuilder
   */
  public static com.brierley.avro.schemas.Cadence.Builder newBuilder(com.brierley.avro.schemas.Cadence.Builder other) {
    return new com.brierley.avro.schemas.Cadence.Builder(other);
  }

  /**
   * Creates a new Cadence RecordBuilder by copying an existing Cadence instance.
   * @param other The existing instance to copy.
   * @return A new Cadence RecordBuilder
   */
  public static com.brierley.avro.schemas.Cadence.Builder newBuilder(com.brierley.avro.schemas.Cadence other) {
    return new com.brierley.avro.schemas.Cadence.Builder(other);
  }

  /**
   * RecordBuilder for Cadence instances.
   */
  public static class Builder extends org.apache.avro.specific.SpecificRecordBuilderBase<Cadence>
    implements org.apache.avro.data.RecordBuilder<Cadence> {

    /** unique job identifier to find results in hbase */
    private java.lang.CharSequence jobKey;
    /** Total number of records in the given dataset used to calculate the cadence */
    private long numRecords;
    /** Number of customers with exactly 1 transaction in the entire dataset. */
    private long singleVisit;
    /** Total number of unique customers for entire dataset. */
    private long totalCusts;
    /** The time the spark job finished and sent the record. */
    private java.lang.CharSequence completionTime;
    /** Beginning date of entire date set used to calculate the cadence */
    private java.lang.CharSequence minDateCadence;
    /** Last date of entire data set used to calculate the cadence */
    private java.lang.CharSequence maxDateCadence;
    /** The cadence calculated with the given percentage before rounding to an approved timeperiod. */
    private double rawCadence;
    /** The cadence value that will be used when running the actual balor calculations, this always rounds up. */
    private java.lang.CharSequence normalizedCadence;
    /** The number of time periods that are present in the given data file using the normalized cadence value. */
    private int numTimePeriods;
    /** The percentile that was used in calculating the cadence. Defaults to .80, but power users can change it. */
    private double percentile;
    private java.util.List<com.brierley.avro.schemas.FreqRow> FreqTable;

    /** Creates a new Builder */
    private Builder() {
      super(SCHEMA$);
    }

    /**
     * Creates a Builder by copying an existing Builder.
     * @param other The existing Builder to copy.
     */
    private Builder(com.brierley.avro.schemas.Cadence.Builder other) {
      super(other);
      if (isValidValue(fields()[0], other.jobKey)) {
        this.jobKey = data().deepCopy(fields()[0].schema(), other.jobKey);
        fieldSetFlags()[0] = true;
      }
      if (isValidValue(fields()[1], other.numRecords)) {
        this.numRecords = data().deepCopy(fields()[1].schema(), other.numRecords);
        fieldSetFlags()[1] = true;
      }
      if (isValidValue(fields()[2], other.singleVisit)) {
        this.singleVisit = data().deepCopy(fields()[2].schema(), other.singleVisit);
        fieldSetFlags()[2] = true;
      }
      if (isValidValue(fields()[3], other.totalCusts)) {
        this.totalCusts = data().deepCopy(fields()[3].schema(), other.totalCusts);
        fieldSetFlags()[3] = true;
      }
      if (isValidValue(fields()[4], other.completionTime)) {
        this.completionTime = data().deepCopy(fields()[4].schema(), other.completionTime);
        fieldSetFlags()[4] = true;
      }
      if (isValidValue(fields()[5], other.minDateCadence)) {
        this.minDateCadence = data().deepCopy(fields()[5].schema(), other.minDateCadence);
        fieldSetFlags()[5] = true;
      }
      if (isValidValue(fields()[6], other.maxDateCadence)) {
        this.maxDateCadence = data().deepCopy(fields()[6].schema(), other.maxDateCadence);
        fieldSetFlags()[6] = true;
      }
      if (isValidValue(fields()[7], other.rawCadence)) {
        this.rawCadence = data().deepCopy(fields()[7].schema(), other.rawCadence);
        fieldSetFlags()[7] = true;
      }
      if (isValidValue(fields()[8], other.normalizedCadence)) {
        this.normalizedCadence = data().deepCopy(fields()[8].schema(), other.normalizedCadence);
        fieldSetFlags()[8] = true;
      }
      if (isValidValue(fields()[9], other.numTimePeriods)) {
        this.numTimePeriods = data().deepCopy(fields()[9].schema(), other.numTimePeriods);
        fieldSetFlags()[9] = true;
      }
      if (isValidValue(fields()[10], other.percentile)) {
        this.percentile = data().deepCopy(fields()[10].schema(), other.percentile);
        fieldSetFlags()[10] = true;
      }
      if (isValidValue(fields()[11], other.FreqTable)) {
        this.FreqTable = data().deepCopy(fields()[11].schema(), other.FreqTable);
        fieldSetFlags()[11] = true;
      }
    }

    /**
     * Creates a Builder by copying an existing Cadence instance
     * @param other The existing instance to copy.
     */
    private Builder(com.brierley.avro.schemas.Cadence other) {
            super(SCHEMA$);
      if (isValidValue(fields()[0], other.jobKey)) {
        this.jobKey = data().deepCopy(fields()[0].schema(), other.jobKey);
        fieldSetFlags()[0] = true;
      }
      if (isValidValue(fields()[1], other.numRecords)) {
        this.numRecords = data().deepCopy(fields()[1].schema(), other.numRecords);
        fieldSetFlags()[1] = true;
      }
      if (isValidValue(fields()[2], other.singleVisit)) {
        this.singleVisit = data().deepCopy(fields()[2].schema(), other.singleVisit);
        fieldSetFlags()[2] = true;
      }
      if (isValidValue(fields()[3], other.totalCusts)) {
        this.totalCusts = data().deepCopy(fields()[3].schema(), other.totalCusts);
        fieldSetFlags()[3] = true;
      }
      if (isValidValue(fields()[4], other.completionTime)) {
        this.completionTime = data().deepCopy(fields()[4].schema(), other.completionTime);
        fieldSetFlags()[4] = true;
      }
      if (isValidValue(fields()[5], other.minDateCadence)) {
        this.minDateCadence = data().deepCopy(fields()[5].schema(), other.minDateCadence);
        fieldSetFlags()[5] = true;
      }
      if (isValidValue(fields()[6], other.maxDateCadence)) {
        this.maxDateCadence = data().deepCopy(fields()[6].schema(), other.maxDateCadence);
        fieldSetFlags()[6] = true;
      }
      if (isValidValue(fields()[7], other.rawCadence)) {
        this.rawCadence = data().deepCopy(fields()[7].schema(), other.rawCadence);
        fieldSetFlags()[7] = true;
      }
      if (isValidValue(fields()[8], other.normalizedCadence)) {
        this.normalizedCadence = data().deepCopy(fields()[8].schema(), other.normalizedCadence);
        fieldSetFlags()[8] = true;
      }
      if (isValidValue(fields()[9], other.numTimePeriods)) {
        this.numTimePeriods = data().deepCopy(fields()[9].schema(), other.numTimePeriods);
        fieldSetFlags()[9] = true;
      }
      if (isValidValue(fields()[10], other.percentile)) {
        this.percentile = data().deepCopy(fields()[10].schema(), other.percentile);
        fieldSetFlags()[10] = true;
      }
      if (isValidValue(fields()[11], other.FreqTable)) {
        this.FreqTable = data().deepCopy(fields()[11].schema(), other.FreqTable);
        fieldSetFlags()[11] = true;
      }
    }

    /**
      * Gets the value of the 'jobKey' field.
      * unique job identifier to find results in hbase
      * @return The value.
      */
    public java.lang.CharSequence getJobKey() {
      return jobKey;
    }

    /**
      * Sets the value of the 'jobKey' field.
      * unique job identifier to find results in hbase
      * @param value The value of 'jobKey'.
      * @return This builder.
      */
    public com.brierley.avro.schemas.Cadence.Builder setJobKey(java.lang.CharSequence value) {
      validate(fields()[0], value);
      this.jobKey = value;
      fieldSetFlags()[0] = true;
      return this;
    }

    /**
      * Checks whether the 'jobKey' field has been set.
      * unique job identifier to find results in hbase
      * @return True if the 'jobKey' field has been set, false otherwise.
      */
    public boolean hasJobKey() {
      return fieldSetFlags()[0];
    }


    /**
      * Clears the value of the 'jobKey' field.
      * unique job identifier to find results in hbase
      * @return This builder.
      */
    public com.brierley.avro.schemas.Cadence.Builder clearJobKey() {
      jobKey = null;
      fieldSetFlags()[0] = false;
      return this;
    }

    /**
      * Gets the value of the 'numRecords' field.
      * Total number of records in the given dataset used to calculate the cadence
      * @return The value.
      */
    public java.lang.Long getNumRecords() {
      return numRecords;
    }

    /**
      * Sets the value of the 'numRecords' field.
      * Total number of records in the given dataset used to calculate the cadence
      * @param value The value of 'numRecords'.
      * @return This builder.
      */
    public com.brierley.avro.schemas.Cadence.Builder setNumRecords(long value) {
      validate(fields()[1], value);
      this.numRecords = value;
      fieldSetFlags()[1] = true;
      return this;
    }

    /**
      * Checks whether the 'numRecords' field has been set.
      * Total number of records in the given dataset used to calculate the cadence
      * @return True if the 'numRecords' field has been set, false otherwise.
      */
    public boolean hasNumRecords() {
      return fieldSetFlags()[1];
    }


    /**
      * Clears the value of the 'numRecords' field.
      * Total number of records in the given dataset used to calculate the cadence
      * @return This builder.
      */
    public com.brierley.avro.schemas.Cadence.Builder clearNumRecords() {
      fieldSetFlags()[1] = false;
      return this;
    }

    /**
      * Gets the value of the 'singleVisit' field.
      * Number of customers with exactly 1 transaction in the entire dataset.
      * @return The value.
      */
    public java.lang.Long getSingleVisit() {
      return singleVisit;
    }

    /**
      * Sets the value of the 'singleVisit' field.
      * Number of customers with exactly 1 transaction in the entire dataset.
      * @param value The value of 'singleVisit'.
      * @return This builder.
      */
    public com.brierley.avro.schemas.Cadence.Builder setSingleVisit(long value) {
      validate(fields()[2], value);
      this.singleVisit = value;
      fieldSetFlags()[2] = true;
      return this;
    }

    /**
      * Checks whether the 'singleVisit' field has been set.
      * Number of customers with exactly 1 transaction in the entire dataset.
      * @return True if the 'singleVisit' field has been set, false otherwise.
      */
    public boolean hasSingleVisit() {
      return fieldSetFlags()[2];
    }


    /**
      * Clears the value of the 'singleVisit' field.
      * Number of customers with exactly 1 transaction in the entire dataset.
      * @return This builder.
      */
    public com.brierley.avro.schemas.Cadence.Builder clearSingleVisit() {
      fieldSetFlags()[2] = false;
      return this;
    }

    /**
      * Gets the value of the 'totalCusts' field.
      * Total number of unique customers for entire dataset.
      * @return The value.
      */
    public java.lang.Long getTotalCusts() {
      return totalCusts;
    }

    /**
      * Sets the value of the 'totalCusts' field.
      * Total number of unique customers for entire dataset.
      * @param value The value of 'totalCusts'.
      * @return This builder.
      */
    public com.brierley.avro.schemas.Cadence.Builder setTotalCusts(long value) {
      validate(fields()[3], value);
      this.totalCusts = value;
      fieldSetFlags()[3] = true;
      return this;
    }

    /**
      * Checks whether the 'totalCusts' field has been set.
      * Total number of unique customers for entire dataset.
      * @return True if the 'totalCusts' field has been set, false otherwise.
      */
    public boolean hasTotalCusts() {
      return fieldSetFlags()[3];
    }


    /**
      * Clears the value of the 'totalCusts' field.
      * Total number of unique customers for entire dataset.
      * @return This builder.
      */
    public com.brierley.avro.schemas.Cadence.Builder clearTotalCusts() {
      fieldSetFlags()[3] = false;
      return this;
    }

    /**
      * Gets the value of the 'completionTime' field.
      * The time the spark job finished and sent the record.
      * @return The value.
      */
    public java.lang.CharSequence getCompletionTime() {
      return completionTime;
    }

    /**
      * Sets the value of the 'completionTime' field.
      * The time the spark job finished and sent the record.
      * @param value The value of 'completionTime'.
      * @return This builder.
      */
    public com.brierley.avro.schemas.Cadence.Builder setCompletionTime(java.lang.CharSequence value) {
      validate(fields()[4], value);
      this.completionTime = value;
      fieldSetFlags()[4] = true;
      return this;
    }

    /**
      * Checks whether the 'completionTime' field has been set.
      * The time the spark job finished and sent the record.
      * @return True if the 'completionTime' field has been set, false otherwise.
      */
    public boolean hasCompletionTime() {
      return fieldSetFlags()[4];
    }


    /**
      * Clears the value of the 'completionTime' field.
      * The time the spark job finished and sent the record.
      * @return This builder.
      */
    public com.brierley.avro.schemas.Cadence.Builder clearCompletionTime() {
      completionTime = null;
      fieldSetFlags()[4] = false;
      return this;
    }

    /**
      * Gets the value of the 'minDateCadence' field.
      * Beginning date of entire date set used to calculate the cadence
      * @return The value.
      */
    public java.lang.CharSequence getMinDateCadence() {
      return minDateCadence;
    }

    /**
      * Sets the value of the 'minDateCadence' field.
      * Beginning date of entire date set used to calculate the cadence
      * @param value The value of 'minDateCadence'.
      * @return This builder.
      */
    public com.brierley.avro.schemas.Cadence.Builder setMinDateCadence(java.lang.CharSequence value) {
      validate(fields()[5], value);
      this.minDateCadence = value;
      fieldSetFlags()[5] = true;
      return this;
    }

    /**
      * Checks whether the 'minDateCadence' field has been set.
      * Beginning date of entire date set used to calculate the cadence
      * @return True if the 'minDateCadence' field has been set, false otherwise.
      */
    public boolean hasMinDateCadence() {
      return fieldSetFlags()[5];
    }


    /**
      * Clears the value of the 'minDateCadence' field.
      * Beginning date of entire date set used to calculate the cadence
      * @return This builder.
      */
    public com.brierley.avro.schemas.Cadence.Builder clearMinDateCadence() {
      minDateCadence = null;
      fieldSetFlags()[5] = false;
      return this;
    }

    /**
      * Gets the value of the 'maxDateCadence' field.
      * Last date of entire data set used to calculate the cadence
      * @return The value.
      */
    public java.lang.CharSequence getMaxDateCadence() {
      return maxDateCadence;
    }

    /**
      * Sets the value of the 'maxDateCadence' field.
      * Last date of entire data set used to calculate the cadence
      * @param value The value of 'maxDateCadence'.
      * @return This builder.
      */
    public com.brierley.avro.schemas.Cadence.Builder setMaxDateCadence(java.lang.CharSequence value) {
      validate(fields()[6], value);
      this.maxDateCadence = value;
      fieldSetFlags()[6] = true;
      return this;
    }

    /**
      * Checks whether the 'maxDateCadence' field has been set.
      * Last date of entire data set used to calculate the cadence
      * @return True if the 'maxDateCadence' field has been set, false otherwise.
      */
    public boolean hasMaxDateCadence() {
      return fieldSetFlags()[6];
    }


    /**
      * Clears the value of the 'maxDateCadence' field.
      * Last date of entire data set used to calculate the cadence
      * @return This builder.
      */
    public com.brierley.avro.schemas.Cadence.Builder clearMaxDateCadence() {
      maxDateCadence = null;
      fieldSetFlags()[6] = false;
      return this;
    }

    /**
      * Gets the value of the 'rawCadence' field.
      * The cadence calculated with the given percentage before rounding to an approved timeperiod.
      * @return The value.
      */
    public java.lang.Double getRawCadence() {
      return rawCadence;
    }

    /**
      * Sets the value of the 'rawCadence' field.
      * The cadence calculated with the given percentage before rounding to an approved timeperiod.
      * @param value The value of 'rawCadence'.
      * @return This builder.
      */
    public com.brierley.avro.schemas.Cadence.Builder setRawCadence(double value) {
      validate(fields()[7], value);
      this.rawCadence = value;
      fieldSetFlags()[7] = true;
      return this;
    }

    /**
      * Checks whether the 'rawCadence' field has been set.
      * The cadence calculated with the given percentage before rounding to an approved timeperiod.
      * @return True if the 'rawCadence' field has been set, false otherwise.
      */
    public boolean hasRawCadence() {
      return fieldSetFlags()[7];
    }


    /**
      * Clears the value of the 'rawCadence' field.
      * The cadence calculated with the given percentage before rounding to an approved timeperiod.
      * @return This builder.
      */
    public com.brierley.avro.schemas.Cadence.Builder clearRawCadence() {
      fieldSetFlags()[7] = false;
      return this;
    }

    /**
      * Gets the value of the 'normalizedCadence' field.
      * The cadence value that will be used when running the actual balor calculations, this always rounds up.
      * @return The value.
      */
    public java.lang.CharSequence getNormalizedCadence() {
      return normalizedCadence;
    }

    /**
      * Sets the value of the 'normalizedCadence' field.
      * The cadence value that will be used when running the actual balor calculations, this always rounds up.
      * @param value The value of 'normalizedCadence'.
      * @return This builder.
      */
    public com.brierley.avro.schemas.Cadence.Builder setNormalizedCadence(java.lang.CharSequence value) {
      validate(fields()[8], value);
      this.normalizedCadence = value;
      fieldSetFlags()[8] = true;
      return this;
    }

    /**
      * Checks whether the 'normalizedCadence' field has been set.
      * The cadence value that will be used when running the actual balor calculations, this always rounds up.
      * @return True if the 'normalizedCadence' field has been set, false otherwise.
      */
    public boolean hasNormalizedCadence() {
      return fieldSetFlags()[8];
    }


    /**
      * Clears the value of the 'normalizedCadence' field.
      * The cadence value that will be used when running the actual balor calculations, this always rounds up.
      * @return This builder.
      */
    public com.brierley.avro.schemas.Cadence.Builder clearNormalizedCadence() {
      normalizedCadence = null;
      fieldSetFlags()[8] = false;
      return this;
    }

    /**
      * Gets the value of the 'numTimePeriods' field.
      * The number of time periods that are present in the given data file using the normalized cadence value.
      * @return The value.
      */
    public java.lang.Integer getNumTimePeriods() {
      return numTimePeriods;
    }

    /**
      * Sets the value of the 'numTimePeriods' field.
      * The number of time periods that are present in the given data file using the normalized cadence value.
      * @param value The value of 'numTimePeriods'.
      * @return This builder.
      */
    public com.brierley.avro.schemas.Cadence.Builder setNumTimePeriods(int value) {
      validate(fields()[9], value);
      this.numTimePeriods = value;
      fieldSetFlags()[9] = true;
      return this;
    }

    /**
      * Checks whether the 'numTimePeriods' field has been set.
      * The number of time periods that are present in the given data file using the normalized cadence value.
      * @return True if the 'numTimePeriods' field has been set, false otherwise.
      */
    public boolean hasNumTimePeriods() {
      return fieldSetFlags()[9];
    }


    /**
      * Clears the value of the 'numTimePeriods' field.
      * The number of time periods that are present in the given data file using the normalized cadence value.
      * @return This builder.
      */
    public com.brierley.avro.schemas.Cadence.Builder clearNumTimePeriods() {
      fieldSetFlags()[9] = false;
      return this;
    }

    /**
      * Gets the value of the 'percentile' field.
      * The percentile that was used in calculating the cadence. Defaults to .80, but power users can change it.
      * @return The value.
      */
    public java.lang.Double getPercentile() {
      return percentile;
    }

    /**
      * Sets the value of the 'percentile' field.
      * The percentile that was used in calculating the cadence. Defaults to .80, but power users can change it.
      * @param value The value of 'percentile'.
      * @return This builder.
      */
    public com.brierley.avro.schemas.Cadence.Builder setPercentile(double value) {
      validate(fields()[10], value);
      this.percentile = value;
      fieldSetFlags()[10] = true;
      return this;
    }

    /**
      * Checks whether the 'percentile' field has been set.
      * The percentile that was used in calculating the cadence. Defaults to .80, but power users can change it.
      * @return True if the 'percentile' field has been set, false otherwise.
      */
    public boolean hasPercentile() {
      return fieldSetFlags()[10];
    }


    /**
      * Clears the value of the 'percentile' field.
      * The percentile that was used in calculating the cadence. Defaults to .80, but power users can change it.
      * @return This builder.
      */
    public com.brierley.avro.schemas.Cadence.Builder clearPercentile() {
      fieldSetFlags()[10] = false;
      return this;
    }

    /**
      * Gets the value of the 'FreqTable' field.
      * @return The value.
      */
    public java.util.List<com.brierley.avro.schemas.FreqRow> getFreqTable() {
      return FreqTable;
    }

    /**
      * Sets the value of the 'FreqTable' field.
      * @param value The value of 'FreqTable'.
      * @return This builder.
      */
    public com.brierley.avro.schemas.Cadence.Builder setFreqTable(java.util.List<com.brierley.avro.schemas.FreqRow> value) {
      validate(fields()[11], value);
      this.FreqTable = value;
      fieldSetFlags()[11] = true;
      return this;
    }

    /**
      * Checks whether the 'FreqTable' field has been set.
      * @return True if the 'FreqTable' field has been set, false otherwise.
      */
    public boolean hasFreqTable() {
      return fieldSetFlags()[11];
    }


    /**
      * Clears the value of the 'FreqTable' field.
      * @return This builder.
      */
    public com.brierley.avro.schemas.Cadence.Builder clearFreqTable() {
      FreqTable = null;
      fieldSetFlags()[11] = false;
      return this;
    }

    @Override
    public Cadence build() {
      try {
        Cadence record = new Cadence();
        record.jobKey = fieldSetFlags()[0] ? this.jobKey : (java.lang.CharSequence) defaultValue(fields()[0]);
        record.numRecords = fieldSetFlags()[1] ? this.numRecords : (java.lang.Long) defaultValue(fields()[1]);
        record.singleVisit = fieldSetFlags()[2] ? this.singleVisit : (java.lang.Long) defaultValue(fields()[2]);
        record.totalCusts = fieldSetFlags()[3] ? this.totalCusts : (java.lang.Long) defaultValue(fields()[3]);
        record.completionTime = fieldSetFlags()[4] ? this.completionTime : (java.lang.CharSequence) defaultValue(fields()[4]);
        record.minDateCadence = fieldSetFlags()[5] ? this.minDateCadence : (java.lang.CharSequence) defaultValue(fields()[5]);
        record.maxDateCadence = fieldSetFlags()[6] ? this.maxDateCadence : (java.lang.CharSequence) defaultValue(fields()[6]);
        record.rawCadence = fieldSetFlags()[7] ? this.rawCadence : (java.lang.Double) defaultValue(fields()[7]);
        record.normalizedCadence = fieldSetFlags()[8] ? this.normalizedCadence : (java.lang.CharSequence) defaultValue(fields()[8]);
        record.numTimePeriods = fieldSetFlags()[9] ? this.numTimePeriods : (java.lang.Integer) defaultValue(fields()[9]);
        record.percentile = fieldSetFlags()[10] ? this.percentile : (java.lang.Double) defaultValue(fields()[10]);
        record.FreqTable = fieldSetFlags()[11] ? this.FreqTable : (java.util.List<com.brierley.avro.schemas.FreqRow>) defaultValue(fields()[11]);
        return record;
      } catch (Exception e) {
        throw new org.apache.avro.AvroRuntimeException(e);
      }
    }
  }

  private static final org.apache.avro.io.DatumWriter
    WRITER$ = new org.apache.avro.specific.SpecificDatumWriter(SCHEMA$);

  @Override public void writeExternal(java.io.ObjectOutput out)
    throws java.io.IOException {
    WRITER$.write(this, SpecificData.getEncoder(out));
  }

  private static final org.apache.avro.io.DatumReader
    READER$ = new org.apache.avro.specific.SpecificDatumReader(SCHEMA$);

  @Override public void readExternal(java.io.ObjectInput in)
    throws java.io.IOException {
    READER$.read(this, SpecificData.getDecoder(in));
  }

}
